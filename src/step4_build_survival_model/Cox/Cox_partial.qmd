---
title: 'Build Survival Model: Cox Proportional Hazards Model'
author: 'Mingcheng Hu'
params:
    adjust_type:
        label: 'Adjustment Type of Survival Model'
        value: 'partial'
        choices:
            - 'minimal'
            - 'partial'
            - 'full'
    impute_type:
        label: 'Imputation Type'
        value: 'unimputed'
        choices:
            - 'unimputed'
            - 'imputed'
    include_statin:
        label: 'Include Participants Taking Statin in the Model'
        value: 'no'
        choices:
            - 'yes'
            - 'no'
format: 
    pdf:
        toc: true
        keep-tex: true
        include-in-header: 
            text: |
                \usepackage{fvextra}
                \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
                \DefineVerbatimEnvironment{OutputCode}{Verbatim}{breaklines,commandchars=\\\{\}}
---


```{r output = FALSE}
library(tidyverse)
library(survival)
library(forestplot)
library(glmnet)
library(ggfortify)
library(kableExtra) # include knitr automatically

source("/work/users/y/u/yuukias/BIOS-Material/BIOS992/utils/csv_utils.r")
# * Don't use setwd() for Quarto documents!
# setwd("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data")

adjust_type <- ifelse(exists("params"), params$adjust_type, "partial") # options: "minimal", "partial", "full"
impute_type <- ifelse(exists("params"), params$impute_type, "unimputed") # options: "unimputed", "imputed"
include_statin <- ifelse(exists("params"), params$include_statin, "no") # options: "yes", "no"
```

```{r}
# string of parameters
adjust_type_str <- switch(adjust_type,
    minimal = "minimal",
    partial = "partial",
    full = "full"
)
print(paste0("Model Adjustment Type: ", adjust_type_str))
impute_type_str <- switch(impute_type,
    unimputed = "unimputed",
    imputed = "imputed"
)
print(paste0("Data Imputation Type: ", impute_type_str))
```

# Load Data

```{r}
if (include_statin == "yes") {
    data_train <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/train_data_", impute_type_str, "_statin.csv"),
        header = TRUE
    )
} else {
    data_train <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/train_data_", impute_type_str, ".csv"),
        header = TRUE
    )
}

data_train <- data_train[, -1] # the first column is the index generated by sklearn
(dim(data_train))
```

```{r}
data <- select_subset(data_train, type = adjust_type)
(dim(data))
```

```{r}
colnames(data)
```

```{r}
data <- tibble::as_tibble(data)
```

```{r}
# * It is very hard to compare the HR as different predictors are on different magnitudes, so we need to normalize them.
time_col <- data$time
event_col <- data$event
data <- data %>%
    select(-c(time, event)) %>%
    mutate(across(where(is.numeric), scale)) %>%
    mutate(
        time = time_col,
        event = event_col
    )
```

**Note now the interpretation of HR is different! For example, if HR=1.16 for the predictor in the univariate model fitted using scaled data, it means that each standard deviation increase is associated with 16% higher risk of event.**

```{r}
data_complete <- na.omit(data)
```

# Univariate Cox Proportional Hazards Model

```{r label = "Univariate Cox Proportional Hazards Model", eval = FALSE}
if (!("time" %in% colnames(data) && "event" %in% colnames(data))) {
    stop("time and event columns are required")
}
predictors <- colnames(data)[!colnames(data) %in% c("time", "event")]

results_univariate <- map_dfr(predictors, function(predictor) {
    formula <- as.formula(paste("Surv(time, event) ~", predictor))
    # cox_model_single <- coxph(Surv(time, event) ~ get(predictor), data = data)  # equivalent way
    cox_model_single <- coxph(formula, data = data)

    coef <- coef(cox_model_single) # log hazard ratio
    se <- sqrt(diag(vcov(cox_model_single)))

    hr <- exp(coef)
    lower_ci <- exp(coef - 1.96 * se)
    upper_ci <- exp(coef + 1.96 * se)
    p_value <- summary(cox_model_single)$coefficients[5]

    return(
        data.frame(
            predictor = predictor,
            hr = hr,
            lower_ci = lower_ci,
            upper_ci = upper_ci,
            p_value = p_value
        )
    )
})
results_univariate$hr <- round(results_univariate$hr, 2)
results_univariate$lower_ci <- round(results_univariate$lower_ci, 2)
results_univariate$upper_ci <- round(results_univariate$upper_ci, 2)
results_univariate$ci <- paste0("(", results_univariate$lower_ci, ",", results_univariate$upper_ci, ")")
results_univariate$p_value <- round(results_univariate$p_value, 3)
results_univariate <- results_univariate %>% arrange(desc(hr)) # sort descendingly by HR
```

```{r echo = FALSE, eval = FALSE}
save(results_univariate,
    file = get_data_path("cox_model_univariate", adjust_type_str, impute_type_str, include_statin, model = "cox")
)
```

```{r echo = FALSE}
load(get_data_path("cox_model_univariate", adjust_type_str, impute_type_str, include_statin, model = "cox"))
```

```{r fig.height=30, fig.width=20}
# Create forest plot
results_univariate %>%
    forestplot(
        labeltext = c(predictor, hr, ci, p_value),
        mean = hr,
        lower = lower_ci,
        upper = upper_ci,
        xlab = "Hazard Ratio",
        title = "Univariate Cox Models",
        xlog = TRUE, # * Make sure the CI are not symmetric and need to be transformed
        boxsize = 0.2,
        xticks = c(0.8, 0.9, 1.0, 1.1, 1.2),
        clip = c(0.8, 1.2),
        zero = 1
    ) %>%
    fp_set_style(
        box = "royalblue",
        line = "darkblue",
        summary = "royalblue"
    ) %>%
    fp_add_header(
        predictor = c("Predictor", ""),
        hr = c("Hazard Ratio", "per SD increase"),
        ci = c("95% CI", ""),
        p_value = c("p-value", "")
    ) %>%
    fp_decorate_graph(
        box = gpar(lty = 2, col = "lightgray"),
        graph.pos = 4
    ) %>% # change the position of forest plot
    fp_set_zebra_style("#f9f9f9")
```



# Multivariate Cox Proportional Hazards Model

```{r label = "Multivariate Cox Proportional Hazards Model: All Data", eval = FALSE}
cox_model_full <- coxph(Surv(time, event) ~ ., data = data)
summary(cox_model_full)
```

```{r label = "Multivariate Cox Proportional Hazards Model: Complete Case Analysis", eval = FALSE}
cox_model_full_complete <- coxph(Surv(time, event) ~ ., data = data_complete)
summary(cox_model_full_complete)
```

```{r echo = FALSE, eval = FALSE}
save(cox_model_full,
    cox_model_full_complete,
    file = get_data_path("cox_model_multivariate", adjust_type_str, impute_type_str, include_statin, model = "cox")
)
```

```{r echo = FALSE}
load(get_data_path("cox_model_multivariate", adjust_type_str, impute_type_str, include_statin, model = "cox"))
```

# PH Assumption Assessment

```{r}
cox.zph(cox_model_full)
```

```{r}
cox.zph(cox_model_full_complete)
```

The proportional hazards assumption was tested using Schoenfeld residuals. 
None of the variables violated the PH assumption (all p > 0.05), 
indicating that the Cox proportional hazards model was appropriate for our analysis.

# Variable Selection

## LASSO 

```{r label = "LASSO: Hyperparameter Selection"}
# * LASSO doesn't allow missing values
set.seed(1234)
x <- as.matrix(data_complete %>% select(-c(time, event)))
y <- Surv(data_complete$time, data_complete$event)

# cox_model_lasso.cv <- cv.glmnet(
#     x,
#     y,
#     family = "cox",
#     alpha = 1, # 1 for LASSO, 0 for Ridge
#     nfolds = 10
# )
# plot(cox_model_lasso.cv)  # Plot partial likelihood deviance vs log(lambda)

# * We choose the range based on plot(cox_model_lasso.cv) for previous run when not providing lambda_seq
lambda_seq <- exp(seq(-8, -6, length.out = 100))
cox_model_lasso.cv <- cv.glmnet(
    x,
    y,
    family = "cox",
    alpha = 1, # 1 for LASSO, 0 for Ridge
    nfolds = 10,
    lambda = lambda_seq
)
print(cox_model_lasso.cv$lambda.min)
print(cox_model_lasso.cv$lambda.1se)
```

As mentioned in the paper, we will use the value of hyperparameter `lambda.1se` that gave the most shrunk model but still was within one standard error from the value that gave the lowest error. This is shown to produce consistently better performance than `lambda.min`.

```{r label = "LASSO: Model Fitting", eval = FALSE}
cox_model_lasso <- glmnet(
    x,
    y,
    family = "cox",
    alpha = 1,
    lambda = cox_model_lasso.cv$lambda.1se
)
cox_model_lasso.coef <- coef(cox_model_lasso)
print(cox_model_lasso.coef)
selected_vars <- rownames(cox_model_lasso.coef)[which(cox_model_lasso.coef != 0)]
print(selected_vars)
```

```{r echo = FALSE, eval = FALSE}
save(cox_model_lasso.cv,
    cox_model_lasso,
    cox_model_lasso.coef,
    file = get_data_path("cox_model_lasso", adjust_type_str, impute_type_str, include_statin, model = "cox")
)
```

```{r echo = FALSE}
load(get_data_path("cox_model_lasso", adjust_type_str, impute_type_str, include_statin, model = "cox"))
```

```{r label = "LASSO: Visualize the LASSO Path"}
# * To visualize the LASSO path, we should not supply lambda
cox_model_lasso_fullpath <- glmnet(
    x,
    y,
    family = "cox",
    alpha = 1
)
```

```{r fig.height=30, fig.width=20}
# plot(cox_model_lasso_fullpath, xvar = "lambda", label = TRUE)
autoplot(cox_model_lasso_fullpath, xvar = "lambda", label = TRUE, label.size = 15) +
    theme_bw() +
    theme(legend.position = "bottom") # better way of visualizing the LASSO path
```

## Stepwise Selection based on BIC

```{r label = "Stepwise Selection based on BIC", eval = FALSE}
# * Stepwise selection doesn't allow missing values
cox_model_step <- MASS::stepAIC(cox_model_full_complete,
    direction = "both",
    k = log(nrow(data)), # Use BIC instead of AIC
    trace = FALSE
)
```

```{r echo = FALSE, eval = FALSE}
save(cox_model_step,
    file = get_data_path("cox_model_step", adjust_type_str, impute_type_str, include_statin, model = "cox")
)
```

```{r echo = FALSE}
load(get_data_path("cox_model_step", adjust_type_str, impute_type_str, include_statin, model = "cox"))
```

```{r}
summary(cox_model_step)
```


# Summary of Variable Selection

We will compare the selection of variables from all models we have built.

```{r}
# Obtain the selected variables from all models
variable_names_all <- colnames(data) %>%
    setdiff(c("time", "event"))

variable_names_univariate <- results_univariate %>%
    filter(p_value < 0.05) %>%
    pull(predictor)

variable_names_multivariate <- summary(cox_model_full_complete)$coefficients %>%
    as.data.frame() %>%
    rownames_to_column(var = "predictor") %>% # transpose, "predictor" will now be the column name
    filter(`Pr(>|z|)` < 0.05) %>%
    pull(predictor)

variable_names_lasso <- rownames(cox_model_lasso.coef)[which(cox_model_lasso.coef != 0)]

variable_names_step <- summary(cox_model_step)$coefficients %>%
    as.data.frame() %>%
    filter(`Pr(>|z|)` < 0.05) %>%
    rownames()
```

```{r}
variable_selection_matrix <- matrix(
    0,
    nrow = length(variable_names_all),
    ncol = 4 # univariate, multivariate, lasso, stepwise
)
colnames(variable_selection_matrix) <- c("univariate", "multivariate", "lasso", "stepwise")
rownames(variable_selection_matrix) <- variable_names_all

for (variable in variable_names_all) {
    if (variable %in% variable_names_univariate) {
        variable_selection_matrix[variable, "univariate"] <- 1
    }
    if (variable %in% variable_names_multivariate) {
        variable_selection_matrix[variable, "multivariate"] <- 1
    }
    if (variable %in% variable_names_lasso) {
        variable_selection_matrix[variable, "lasso"] <- 1
    }
    if (variable %in% variable_names_step) {
        variable_selection_matrix[variable, "stepwise"] <- 1
    }
}
```

```{r echo = FALSE}
# Save the selected times for each variable
save(variable_selection_matrix,
    file = get_data_path("cox_var_select_result", adjust_type_str, impute_type_str, include_statin, model = "cox"))
```

```{r echo = FALSE}
load(get_data_path("cox_var_select_result", adjust_type_str, impute_type_str, include_statin, model = "cox"))
```

```{r}
symbol_selected <- "*"

selection_table <- data.frame(
    Variable = variable_names_all,
    Univariate = ifelse(variable_selection_matrix[, "univariate"] == 1, symbol_selected, ""),
    Multivariate = ifelse(variable_selection_matrix[, "multivariate"] == 1, symbol_selected, ""),
    LASSO = ifelse(variable_selection_matrix[, "lasso"] == 1, symbol_selected, ""),
    Stepwise = ifelse(variable_selection_matrix[, "stepwise"] == 1, symbol_selected, "")
) %>%
    mutate(Num_Selected = rowSums(variable_selection_matrix)) %>%
    arrange(desc(Num_Selected), Variable) %>%
    as.data.frame() %>%
    remove_rownames()

variable_categories <- sapply(variable_names_all, determine_category)
category_colors <- c(
    "covariate" = "#FFB6C1", # 浅粉色（柔和好看）
    "time"      = "#1E90FF", # 道奇蓝（经典蓝色）
    "frequency" = "#32CD32", # 酸橙绿（鲜艳绿色）
    "poincare"  = "#FF4500", # 橙红色
    "entropy"   = "#FF8C00", # 深橙色
    "fractal"   = "#FFD700", # 金黄色
    "unknown"   = "#000000" # 纯黑色
)
category_colors_names <- c(
    "covariate"  = "pink", # 浅粉色
    "time"       = "blue", # 蓝色
    "frequency"  = "green", # 绿色
    "poincare"   = "red", # 红色
    "entropy"    = "orange", # 橙色
    "fractal"    = "gold" # 金色
)
category_legend <- sapply(names(category_colors_names), function(cat) {
    sprintf(
        "%s: %s",
        tools::toTitleCase(cat),
        tools::toTitleCase(category_colors_names[cat])
    )
}) %>%
    paste(collapse = "; ")


selection_table %>%
    kbl(
        caption = "Variable Selection by Different Models",
        align = c("|l", "c", "c", "c", "c", "c|"),
        col.names = c("Variable", "Univariate", "Multivariate", "LASSO", "Stepwise", "Selected Times"),
        longtable = TRUE
    ) %>%
    kable_styling(
        bootstrap_options = c("striped", "hover", "condensed", "responsive"),
        position = "center",
        font_size = 9,
        latex_options = c("repeat_header", "striped", "HOLD_position")
    ) %>%
    # Add color for different categories of variables
    column_spec(1,
        color = category_colors[variable_categories[selection_table$Variable]],
        bold = TRUE
    ) %>%
    # Add a header colname for four columns: Univariate, Multivariate, LASSO, Stepwise
    add_header_above(c(
        " " = 1,
        "Selection Methods" = 4,
        " " = 1
    )) %>%
    footnote(
        general = sprintf("%s", category_legend),
        general_title = "Note:"
    )
```





