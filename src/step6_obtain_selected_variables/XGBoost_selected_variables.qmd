---
title: 'Variable Selection Result: XGBoost'
author: 'Mingcheng Hu'
format: 
    pdf:
        toc: true
        keep-tex: true
        include-in-header: 
            text: |
                \usepackage{fvextra}
                \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
                \DefineVerbatimEnvironment{OutputCode}{Verbatim}{breaklines,commandchars=\\\{\}}
---

We compare the variables selected by different models.

```{r}
library(tidyverse)
library(xgboost)
library("SHAPforxgboost")

source("/work/users/y/u/yuukias/BIOS-Material/BIOS992/utils/csv_utils.r")
```

## Minimally-adjusted Model

```{r}
adjust_type <- ifelse(exists("params"), params$adjust_type, "minimal")
adjust_type_str <- "minimal"
impute_type_str <- "unimputed"
include_statin <- "no"
file_path_minimal1 <- get_data_path("xgb_model",
    adjust_type_str,
    impute_type_str,
    include_statin,
    model = "xgb"
)
load(file_path_minimal1)
file_path_minimal2 <- get_data_path("xgb_var_select_name",
    adjust_type_str,
    impute_type_str,
    include_statin,
    model = "xgb"
)
load(file_path_minimal2)
```


```{r label = "Load Data: Minimal", echo = FALSE}
if (include_statin == "yes") {
    data_test <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/test_data_", impute_type_str, "_statin.csv"),
        header = TRUE
    )
} else {
    data_test <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/test_data_", impute_type_str, ".csv"),
        header = TRUE
    )
}

data_test <- data_test[, -1] # the first column is the index generated by sklearn

data <- select_subset(data_test, type = adjust_type)

data <- tibble::as_tibble(data)

# * It is very hard to compare the HR as different predictors are on different magnitudes, so we need to normalize them.
time_col <- data$time
event_col <- data$event
data <- data %>%
    select(-c(time, event)) %>%
    mutate(across(where(is.numeric), scale)) %>%
    mutate(
        time = time_col,
        event = event_col
    )

# For Cox model:
data_complete <- na.omit(data)

# For RSF model: We don't need to exclude the missing values

# For XGBoost model:
test_x <- as.matrix(data_complete %>% select(-c(time, event)))
test_y_lower_bound <- data_complete$time
test_y_upper_bound <- ifelse(data_complete$event == 1, data_complete$time, Inf)
dtest <- xgb.DMatrix(
    data = test_x,
    label_lower_bound = test_y_lower_bound,
    label_upper_bound = test_y_upper_bound
)
dtest_selected <- xgb.DMatrix(
    data = test_x[, vars_selected],
    label_lower_bound = test_y_lower_bound,
    label_upper_bound = test_y_upper_bound
)
```

```{r}
xgb.importance(model = xgb_model)
```


Here we convert the SHAP summary plot to PNG format to avoid large file size.

```{r dev='png', dpi=300, fig.height=30, fig.width=20}
shap_values <- shap.values(xgb_model = xgb_model, X_train = test_x[, vars_selected])
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x[, vars_selected])
shap.plot.summary(shap_long)
```


```{r dev='png', dpi=300, fig.height=30, fig.width=20}
shap_values <- shap.values(xgb_model = xgb_model_full, X_train = test_x)
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x)
shap.plot.summary(shap_long)
```

```{r echo = FALSE}
rm(
    xgb_model, xgb_model_full,
    data_complete, vars_selected,
    test_x, test_y_lower_bound, test_y_upper_bound,
    dtest, dtest_selected
)
```

## Partialy-adjusted Model

```{r}
adjust_type <- ifelse(exists("params"), params$adjust_type, "partial")
adjust_type_str <- "partial"
impute_type_str <- "unimputed"
include_statin <- "no"
file_path_minimal1 <- get_data_path("xgb_model",
    adjust_type_str,
    impute_type_str,
    include_statin,
    model = "xgb"
)
load(file_path_minimal1)
file_path_minimal2 <- get_data_path("xgb_var_select_name",
    adjust_type_str,
    impute_type_str,
    include_statin,
    model = "xgb"
)
load(file_path_minimal2)
```

```{r label = "Load Data: Partial", echo = FALSE}
if (include_statin == "yes") {
    data_test <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/test_data_", impute_type_str, "_statin.csv"),
        header = TRUE
    )
} else {
    data_test <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/test_data_", impute_type_str, ".csv"),
        header = TRUE
    )
}

data_test <- data_test[, -1] # the first column is the index generated by sklearn

data <- select_subset(data_test, type = adjust_type)

data <- tibble::as_tibble(data)

# * It is very hard to compare the HR as different predictors are on different magnitudes, so we need to normalize them.
time_col <- data$time
event_col <- data$event
data <- data %>%
    select(-c(time, event)) %>%
    mutate(across(where(is.numeric), scale)) %>%
    mutate(
        time = time_col,
        event = event_col
    )

# For Cox model:
data_complete <- na.omit(data)

# For RSF model: We don't need to exclude the missing values

# For XGBoost model:
test_x <- as.matrix(data_complete %>% select(-c(time, event)))
test_y_lower_bound <- data_complete$time
test_y_upper_bound <- ifelse(data_complete$event == 1, data_complete$time, Inf)
dtest <- xgb.DMatrix(
    data = test_x,
    label_lower_bound = test_y_lower_bound,
    label_upper_bound = test_y_upper_bound
)
dtest_selected <- xgb.DMatrix(
    data = test_x[, vars_selected],
    label_lower_bound = test_y_lower_bound,
    label_upper_bound = test_y_upper_bound
)
```

```{r}
xgb.importance(model = xgb_model)
```

```{r dev='png', dpi=300, fig.height=30, fig.width=20}
shap_values <- shap.values(xgb_model = xgb_model, X_train = test_x[, vars_selected])
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x[, vars_selected])
shap.plot.summary(shap_long)
```


```{r dev='png', dpi=300, fig.height=30, fig.width=20}
shap_values <- shap.values(xgb_model = xgb_model_full, X_train = test_x)
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x)
shap.plot.summary(shap_long)
```

```{r echo = FALSE}
rm(
    xgb_model, xgb_model_full,
    data_complete, vars_selected,
    test_x, test_y_lower_bound, test_y_upper_bound,
    dtest, dtest_selected
)
```

## Fully-adjusted Model

```{r}
adjust_type <- ifelse(exists("params"), params$adjust_type, "full")
adjust_type_str <- "full"
impute_type_str <- "imputed"
include_statin <- "no"
file_path_minimal1 <- get_data_path("xgb_model",
    adjust_type_str,
    impute_type_str,
    include_statin,
    model = "xgb"
)
load(file_path_minimal1)
file_path_minimal2 <- get_data_path("xgb_var_select_name",
    adjust_type_str,
    impute_type_str,
    include_statin,
    model = "xgb"
)
load(file_path_minimal2)
```


```{r label = "Load Data: Full", echo = FALSE}
if (include_statin == "yes") {
    data_test <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/test_data_", impute_type_str, "_statin.csv"),
        header = TRUE
    )
} else {
    data_test <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/test_data_", impute_type_str, ".csv"),
        header = TRUE
    )
}

data_test <- data_test[, -1] # the first column is the index generated by sklearn

data <- select_subset(data_test, type = adjust_type)

data <- tibble::as_tibble(data)

# * There are some imputed ethnicity set to "e". We will exclude them at this time.
data <- data %>%
    filter(ethnicity != "e")

# * We also need to manually relevel the categorical variables
data <- data %>%
    mutate(
        # Set "Never" (0) as baseline for smoking
        smoking = factor(smoking,
            levels = c("0", "1", "2", "-3"),
            labels = c("Never", "Previous", "Current", "Prefer not to answer")
        ),

        # Set "No" (0) as baseline for diabetes
        diabetes = factor(diabetes,
            levels = c("0", "1", "-1", "-3"),
            labels = c("No", "Yes", "Do not know", "Prefer not to answer")
        ),

        # Ensure other categorical variables are properly factored
        ethnicity = factor(ethnicity,
            levels = c("1", "2", "3", "4", "5", "6"),
            labels = c("White", "Mixed", "Asian/Asian British", "Black/Black British", "Chinese", "Other")
        ),
        education = factor(education,
            levels = c("1", "2", "3", "4", "5", "6", "-7", "-3"),
            labels = c(
                "College/University degree", "A levels/AS levels",
                "O levels/GCSEs", "CSEs", "NVQ/HND/HNC",
                "Other professional", "None of the above",
                "Prefer not to answer"
            )
        ),
        activity = factor(activity,
            levels = c("0", "1", "2"),
            labels = c("Low", "Moderate", "High")
        ),
        sex = factor(sex,
            levels = c("0", "1"),
            labels = c("Female", "Male")
        ),
        hypertension_treatment = factor(hypertension_treatment,
            levels = c("0", "1"),
            labels = c("No", "Yes")
        )
    )


# * It is very hard to compare the HR as different predictors are on different magnitudes, so we need to normalize them.
time_col <- data$time
event_col <- data$event
data <- data %>%
    select(-c(time, event)) %>%
    mutate(across(where(is.numeric), scale)) %>%
    mutate(
        time = time_col,
        event = event_col
    )

# For Cox model:
data_complete <- na.omit(data)

# For RSF model: We don't need to exclude the missing values

# For XGBoost model:
test_x <- data_complete %>% select(-c(time, event))
test_x_xgb <- model.frame(~ . - 1, data = test_x, na.action = na.pass)
test_x_xgb <- model.matrix(~ . - 1, data = test_x_xgb)
test_y_lower_bound <- data_complete$time
test_y_upper_bound <- ifelse(data_complete$event == 1, data_complete$time, Inf)
```


```{r}
xgb.importance(model = xgb_model)
```


```{r dev='png', dpi=300, fig.height=30, fig.width=20}
shap_values <- shap.values(xgb_model = xgb_model, X_train = test_x_xgb[, vars_selected])
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x_xgb[, vars_selected])
shap.plot.summary(shap_long)
```


```{r dev='png', dpi=300, fig.height=30, fig.width=20}
shap_values <- shap.values(xgb_model = xgb_model_full, X_train = test_x_xgb)
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x_xgb)
shap.plot.summary(shap_long)
```