---
title: 'Variable Selection Result: XGBoost'
author: 'Mingcheng Hu'
format: 
    pdf:
        toc: true
        keep-tex: true
        include-in-header: 
            text: |
                \usepackage{fvextra}
                \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
                \DefineVerbatimEnvironment{OutputCode}{Verbatim}{breaklines,commandchars=\\\{\}}
---

We compare the variables selected by different models.

```{r}
library(tidyverse)
library(xgboost)
library("SHAPforxgboost")

source("/work/users/y/u/yuukias/BIOS-Material/BIOS992/utils/csv_utils.r")
```

## Minimally-adjusted Model

```{r}
adjust_type <- ifelse(exists("params"), params$adjust_type, "minimal")
adjust_type_str <- "minimal"
impute_type_str <- "unimputed"
include_statin <- "no"
file_path_minimal1 <- get_data_path("xgb_model",
    adjust_type_str,
    impute_type_str,
    include_statin,
    model = "xgb"
)
load(file_path_minimal1)
file_path_minimal2 <- get_data_path("xgb_var_select_name",
    adjust_type_str,
    impute_type_str,
    include_statin,
    model = "xgb"
)
load(file_path_minimal2)
```


```{r label = "Load Data: Minimal", echo = FALSE}
if (include_statin == "yes") {
    data_test <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/test_data_", impute_type_str, "_statin.csv"),
        header = TRUE
    )
} else {
    data_test <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/test_data_", impute_type_str, ".csv"),
        header = TRUE
    )
}

data_test <- data_test[, -1] # the first column is the index generated by sklearn

data <- select_subset(data_test, type = adjust_type)

data <- tibble::as_tibble(data)

# * It is very hard to compare the HR as different predictors are on different magnitudes, so we need to normalize them.
time_col <- data$time
event_col <- data$event
data <- data %>%
    select(-c(time, event)) %>%
    mutate(across(where(is.numeric), scale)) %>%
    mutate(
        time = time_col,
        event = event_col
    )

# For Cox model:
data_complete <- na.omit(data)

# For RSF model: We don't need to exclude the missing values

# For XGBoost model:
test_x <- as.matrix(data_complete %>% select(-c(time, event)))
test_y_lower_bound <- data_complete$time
test_y_upper_bound <- ifelse(data_complete$event == 1, data_complete$time, Inf)
dtest <- xgb.DMatrix(
    data = test_x,
    label_lower_bound = test_y_lower_bound,
    label_upper_bound = test_y_upper_bound
)
dtest_selected <- xgb.DMatrix(
    data = test_x[, vars_selected],
    label_lower_bound = test_y_lower_bound,
    label_upper_bound = test_y_upper_bound
)
```

```{r}
xgb.importance(model = xgb_model)
```


Here we convert the SHAP summary plot to PNG format to avoid large file size.

```{r dev='png', dpi=300, fig.height=30, fig.width=20}
shap_values <- shap.values(xgb_model = xgb_model, X_train = test_x[, vars_selected])
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x[, vars_selected])
shap.plot.summary(shap_long)
```


```{r dev='png', dpi=300, fig.height=30, fig.width=20}
shap_values <- shap.values(xgb_model = xgb_model_full, X_train = test_x)
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x)
shap.plot.summary(shap_long)
```

```{r echo = FALSE}
rm(
    xgb_model, xgb_model_full,
    data_complete, vars_selected,
    test_x, test_y_lower_bound, test_y_upper_bound,
    dtest, dtest_selected
)
```

## Partialy-adjusted Model

```{r}
adjust_type <- ifelse(exists("params"), params$adjust_type, "partial")
adjust_type_str <- "partial"
impute_type_str <- "unimputed"
include_statin <- "no"
file_path_minimal1 <- get_data_path("xgb_model",
    adjust_type_str,
    impute_type_str,
    include_statin,
    model = "xgb"
)
load(file_path_minimal1)
file_path_minimal2 <- get_data_path("xgb_var_select_name",
    adjust_type_str,
    impute_type_str,
    include_statin,
    model = "xgb"
)
load(file_path_minimal2)
```

```{r label = "Load Data: Partial", echo = FALSE}
if (include_statin == "yes") {
    data_test <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/test_data_", impute_type_str, "_statin.csv"),
        header = TRUE
    )
} else {
    data_test <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/test_data_", impute_type_str, ".csv"),
        header = TRUE
    )
}

data_test <- data_test[, -1] # the first column is the index generated by sklearn

data <- select_subset(data_test, type = adjust_type)

data <- tibble::as_tibble(data)

# * It is very hard to compare the HR as different predictors are on different magnitudes, so we need to normalize them.
time_col <- data$time
event_col <- data$event
data <- data %>%
    select(-c(time, event)) %>%
    mutate(across(where(is.numeric), scale)) %>%
    mutate(
        time = time_col,
        event = event_col
    )

# For Cox model:
data_complete <- na.omit(data)

# For RSF model: We don't need to exclude the missing values

# For XGBoost model:
test_x <- as.matrix(data_complete %>% select(-c(time, event)))
test_y_lower_bound <- data_complete$time
test_y_upper_bound <- ifelse(data_complete$event == 1, data_complete$time, Inf)
dtest <- xgb.DMatrix(
    data = test_x,
    label_lower_bound = test_y_lower_bound,
    label_upper_bound = test_y_upper_bound
)
dtest_selected <- xgb.DMatrix(
    data = test_x[, vars_selected],
    label_lower_bound = test_y_lower_bound,
    label_upper_bound = test_y_upper_bound
)
```

```{r}
xgb.importance(model = xgb_model)
```

```{r dev='png', dpi=300, fig.height=30, fig.width=20}
shap_values <- shap.values(xgb_model = xgb_model, X_train = test_x[, vars_selected])
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x[, vars_selected])
shap.plot.summary(shap_long)
```


```{r dev='png', dpi=300, fig.height=30, fig.width=20}
shap_values <- shap.values(xgb_model = xgb_model_full, X_train = test_x)
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x)
shap.plot.summary(shap_long)
```

```{r echo = FALSE}
rm(
    xgb_model, xgb_model_full,
    data_complete, vars_selected,
    test_x, test_y_lower_bound, test_y_upper_bound,
    dtest, dtest_selected
)
```

## Fully-adjusted Model

```{r}
adjust_type <- ifelse(exists("params"), params$adjust_type, "full")
adjust_type_str <- "full"
impute_type_str <- "imputed"
include_statin <- "no"
file_path_minimal1 <- get_data_path("xgb_model",
    adjust_type_str,
    impute_type_str,
    include_statin,
    model = "xgb"
)
load(file_path_minimal1)
file_path_minimal2 <- get_data_path("xgb_var_select_name",
    adjust_type_str,
    impute_type_str,
    include_statin,
    model = "xgb"
)
load(file_path_minimal2)
```


```{r label = "Load Data: Full", echo = FALSE}
if (include_statin == "yes") {
    data_test <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/test_data_", impute_type_str, "_statin.csv"),
        header = TRUE
    )
} else {
    data_test <- read.csv(paste0("/work/users/y/u/yuukias/BIOS-Material/BIOS992/data/test_data_", impute_type_str, ".csv"),
        header = TRUE
    )
}

data_test <- data_test[, -1] # the first column is the index generated by sklearn

data <- select_subset(data_test, type = adjust_type)

data <- tibble::as_tibble(data)

# * There are some imputed ethnicity set to "e". We will exclude them at this time.
data <- data %>%
    filter(ethnicity != "e")

# * We also need to manually relevel the categorical variables
data <- data %>%
    mutate(
        # Set "Never" (0) as baseline for smoking
        smoking = factor(smoking,
            levels = c("0", "1", "2", "-3"),
            labels = c("Never", "Previous", "Current", "Prefer not to answer")
        ),

        # Set "No" (0) as baseline for diabetes
        diabetes = factor(diabetes,
            levels = c("0", "1", "-1", "-3"),
            labels = c("No", "Yes", "Do not know", "Prefer not to answer")
        ),

        # Ensure other categorical variables are properly factored
        ethnicity = factor(ethnicity,
            levels = c("1", "2", "3", "4", "5", "6"),
            labels = c("White", "Mixed", "Asian/Asian British", "Black/Black British", "Chinese", "Other")
        ),
        education = factor(education,
            levels = c("1", "2", "3", "4", "5", "6", "-7", "-3"),
            labels = c(
                "College/University degree", "A levels/AS levels",
                "O levels/GCSEs", "CSEs", "NVQ/HND/HNC",
                "Other professional", "None of the above",
                "Prefer not to answer"
            )
        ),
        activity = factor(activity,
            levels = c("0", "1", "2"),
            labels = c("Low", "Moderate", "High")
        ),
        sex = factor(sex,
            levels = c("0", "1"),
            labels = c("Female", "Male")
        ),
        hypertension_treatment = factor(hypertension_treatment,
            levels = c("0", "1"),
            labels = c("No", "Yes")
        )
    )


# * It is very hard to compare the HR as different predictors are on different magnitudes, so we need to normalize them.
time_col <- data$time
event_col <- data$event
data <- data %>%
    select(-c(time, event)) %>%
    mutate(across(where(is.numeric), scale)) %>%
    mutate(
        time = time_col,
        event = event_col
    )

# For Cox model:
data_complete <- na.omit(data)

# For RSF model: We don't need to exclude the missing values

# For XGBoost model:
test_x <- data_complete %>% select(-c(time, event))
test_x_xgb <- model.frame(~ . - 1, data = test_x, na.action = na.pass)
test_x_xgb <- model.matrix(~ . - 1, data = test_x_xgb)
test_y_lower_bound <- data_complete$time
test_y_upper_bound <- ifelse(data_complete$event == 1, data_complete$time, Inf)
```


```{r}
xgb.importance(model = xgb_model)
```


```{r dev='png', dpi=300, fig.height=30, fig.width=20}
shap_values <- shap.values(xgb_model = xgb_model, X_train = test_x_xgb[, vars_selected])
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x_xgb[, vars_selected])
shap.plot.summary(shap_long)
```


```{r eval = FALSE}
format_predictor_names <- function(predictor) {
    name_map <- c(
        "age" = "Age",
        "BMI" = "Body Mass Index",
        "diabetesYes" = "Diabetes: Yes",
        "diabetesDo not know" = "Diabetes: Don't know",
        "diabetesPrefer not to answer" = "Diabetes: Prefer not to answer",
        "hypertension_treatmentYes" = "Hypertension Treatment: Yes",
        "sexMale" = "Sex: Male",
        "systolic_bp" = "Systolic Blood Pressure",
        "total_chol" = "Total Cholesterol",
        "hdl_chol" = "HDL Cholesterol",
        "max_workload" = "Maximum Workload",
        "max_heart_rate" = "Maximum Heart Rate"
    )

    if (grepl("^ethnicity", predictor)) {
        return(paste0("Ethnicity: ", gsub("^ethnicity", "", predictor)))
    }
    if (grepl("^smoking", predictor)) {
        return(paste0("Smoking: ", gsub("^smoking", "", predictor)))
    }
    if (grepl("^education", predictor)) {
        return(paste0("Education: ", gsub("^education", "", predictor)))
    }
    if (grepl("^activity", predictor)) {
        return(paste0("Physical Activity: ", gsub("^activity", "", predictor)))
    }

    if (grepl("^HRV_", predictor)) {
        clean_name <- gsub("^HRV_", "", predictor)

        if (clean_name %in% c(
            "SD1", "SD2", "SD1SD2", "S", "CSI", "CVI",
            "CSI_Modified", "PIP", "IALS", "PSS", "PAS",
            "GI", "SI", "AI", "PI", "C1d", "C1a",
            "SD1d", "SD1a", "C2d", "C2a", "SD2d", "SD2a",
            "Cd", "Ca", "SDNNd", "SDNNa"
        )) {
            return(paste0(clean_name, " (Poincare)"))
        }
        # Entropy measures
        else if (clean_name %in% c("ApEn", "ShanEn", "FuzzyEn", "MSEn", "CMSEn", "RCMSEn")) {
            return(paste0(clean_name, " (Entropy)"))
        }
        # Fractal measures
        else if (clean_name %in% c(
            "CD", "HFD", "KFD", "LZC", "DFA_alpha1",
            "MFDFA_alpha1_Width", "MFDFA_alpha1_Peak",
            "MFDFA_alpha1_Mean", "MFDFA_alpha1_Max", "MFDFA_alpha1_Delta",
            "MFDFA_alpha1_Asymmetry", "MFDFA_alpha1_Fluctuation",
            "MFDFA_alpha1_Increment"
        )) {
            return(paste0(clean_name, " (Fractal)"))
        }
        # Time domain measures
        else if (clean_name %in% c(
            "MeanNN", "SDNN", "RMSSD", "SDSD", "CVNN",
            "CVSD", "MedianNN", "MadNN", "MCVNN", "IQRNN",
            "SDRMSSD", "Prc20NN", "Prc80NN", "pNN50", "pNN20",
            "MinNN", "MaxNN", "HTI", "TINN"
        )) {
            return(paste0(clean_name, " (Time)"))
        }
        # Frequency domain measures
        else if (clean_name %in% c(
            "LF", "HF", "VHF", "TP", "LFHF", "LFn",
            "HFn", "LnHF"
        )) {
            return(paste0(clean_name, " (Frequency)"))
        }
    }

    return(name_map[predictor] %||% predictor)
}
```

```{r eval = FALSE}
png("/work/users/y/u/yuukias/BIOS-Material/BIOS992/src/paper_writing/shap.png",
    height = 3000,
    width = 2000,
    res = 300
)

shap_values <- shap.values(xgb_model = xgb_model, X_train = test_x_xgb[, vars_selected])
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x_xgb[, vars_selected])
shap_long$variable <- sapply(shap_long$variable, format_predictor_names)
shap_long$variable <- factor(shap_long$variable, levels = unique(shap_long$variable))
shap.plot.summary(shap_long, dilute = 5)  # dilute to plot less data (1/5)
dev.off()
```

```{r dev='png', dpi=300, fig.height=30, fig.width=20}
shap_values <- shap.values(xgb_model = xgb_model_full, X_train = test_x_xgb)
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x_xgb)
shap.plot.summary(shap_long)
```

```{r eval = FALSE}
png("/work/users/y/u/yuukias/BIOS-Material/BIOS992/src/paper_writing/shap_full.png",
    height = 15000,
    width = 10000,
    res = 600
)

shap_values <- shap.values(xgb_model = xgb_model_full, X_train = test_x_xgb)
shap_long <- shap.prep(shap_contrib = shap_values$shap_score, X_train = test_x_xgb)
shap_long$variable <- sapply(shap_long$variable, format_predictor_names)
shap_long$variable <- factor(shap_long$variable, levels = unique(shap_long$variable))
shap.plot.summary(shap_long, dilute = 10)  # dilute to plot less data (1/5)
dev.off()
```